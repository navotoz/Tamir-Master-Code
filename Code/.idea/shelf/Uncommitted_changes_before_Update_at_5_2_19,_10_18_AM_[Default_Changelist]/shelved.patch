Index: ROS/gazebo/arm_controller_ur5.yaml
===================================================================
--- ROS/gazebo/arm_controller_ur5.yaml	(revision 9471f81a6a8d7a0d6d81bd659d8eece643f9cc85)
+++ ROS/gazebo/arm_controller_ur5.yaml	(revision 9471f81a6a8d7a0d6d81bd659d8eece643f9cc85)
@@ -1,29 +0,0 @@
-arm_controller:
-  type: position_controllers/JointTrajectoryController
-  joints:
-     - shoulder_pan_joint
-     - shoulder_lift_joint
-     - elbow_joint
-     - wrist_1_joint
-     - wrist_2_joint
-     - wrist_3_joint
-  constraints:
-      goal_time: 0.6
-      stopped_velocity_tolerance: 0.05
-      shoulder_pan_joint: {trajectory: 0.1, goal: 0.1}
-      shoulder_lift_joint: {trajectory: 0.1, goal: 0.1}
-      elbow_joint: {trajectory: 0.1, goal: 0.1}
-      wrist_1_joint: {trajectory: 0.1, goal: 0.1}
-      wrist_2_joint: {trajectory: 0.1, goal: 0.1}
-      wrist_3_joint: {trajectory: 0.1, goal: 0.1}
-  stop_trajectory_duration: 0.5
-  state_publish_rate:  25
-  action_monitor_rate: 10
-
-#/gazebo_ros_control/pid_gains:
-#  shoulder_pan_joint: {p: 100.0, i: 1, d: 1}
-#  shoulder_lift_joint: {p: 100.0, i: 1, d: 1}
-#  elbow_joint: {p: 100.0, i: 1, d: 1}
-#  wrist_1_joint: {p: 100.0, i: 1, d: 1}
-#  wrist_2_joint: {p: 100.0, i: 1, d: 1}
-#  wrist_3_joint: {p: 100.0, i: 1, d: 1}
Index: SimFilesCreate.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\"\"\" i Will create many URDF files as the number of manipulators that i want to simulate\nlinks lengths- check from [0.1-1]meter in intervals of 0.3 meter\n# of DOF- check between 3-6 DOF\ntype of DOF - check 2 types - prismatic and revolute\norder- for each # and type of DOF i will check all the possible options\n\"\"\"\nimport datetime\nimport itertools\nimport os\nfrom logging import warning\nimport numpy as np\n\n\nclass UrdfClass(object):\n    \"\"\" this class create URDF files \"\"\"\n\n    def __init__(self, links=[], joints=[], joints_axis=[], rpy=[]):\n        \"\"\"\n        :param joints: array of joints types- can be 'revolute' or 'prismatic'\n        :param links: array of the links lengths in meters [must be positive float]\n        the first link will be the base link, who is always the same(connected to the world and link1  - his joint is limited to 0)\n        \"\"\"\n        if not joints:\n            joints = ['revolute', 'prismatic', 'revolute', 'revolute', 'revolute', 'revolute']\n        if not joints_axis:\n            joints_axis = ['z', 'y', 'y', 'y', 'z', 'y']\n        if not links:\n            links = [1, 1, 1, 1, 1, 1]\n        self.links = links\n        self.joint_data = joints\n        self.axis = self.init_calc(joints, joints_axis)\n        self.links_number = len(self.links)\n        self.rpy = rpy\n\n    def urdf_data(self):\n        head = '''<?xml version=\"1.0\"?>\n<robot xmlns:xacro=\"http://wiki.ros.org/xacro\">\n\n  <xacro:include filename=\"$(find ur_description)/urdf/ur.transmission.xacro\" />\n  <xacro:include filename=\"$(find ur_description)/urdf/ur.gazebo.xacro\" />\n\n  <xacro:macro name=\"cylinder_inertial\" params=\"radius length mass *origin\">\n    <inertial>\n      <mass value=\"${mass}\" />\n      <xacro:insert_block name=\"origin\" />\n      <inertia ixx=\"${0.0833333 * mass * (3 * radius * radius + length * length)}\" ixy=\"0.0\" ixz=\"0.0\"\n        iyy=\"${0.0833333 * mass * (3 * radius * radius + length * length)}\" iyz=\"0.0\"\n        izz=\"${0.5 * mass * radius * radius}\" />\n    </inertial>\n  </xacro:macro>\n\n<xacro:macro name=\"joint_limit\" params=\"joint_type link_length \">\n\t<xacro:if value=\"${joint_type == 'revolute'}\"  >\n\t\t<xacro:property name=\"joint_upper_limit\" value=\"${pi}\" /> \n\t\t<xacro:property name=\"joint_lower_limit\" value=\"${-pi}\" /> \n\t</xacro:if>\n\t<xacro:unless value=\"${joint_type == 'revolute'}\"  >\n\t\t<xacro:property name=\"joint_upper_limit\" value=\"${2*link_length}\" /> \n\t\t<xacro:property name=\"joint_lower_limit\" value=\"${0}\" />  \n\t</xacro:unless>\n\t<limit lower=\"${joint_lower_limit}\" upper=\"${joint_upper_limit}\" effort=\"150.0\" velocity=\"3.15\"/>\n</xacro:macro>\n\n\n  <xacro:macro name=\"ur5_robot\" params=\"prefix joint_limited\">'''\n        inertia_parameters = '''\n        <xacro:property name=\"base_length\" value=\"0.05\"/>\n            <!-- Inertia parameters -->\n        <xacro:property name=\"base_mass\" value=\"4.0\" /> \n        <xacro:property name=\"link1_mass\" value=\"3.7\" />\n        <xacro:property name=\"link2_mass\" value=\"8.393\" />\n        <xacro:property name=\"link3_mass\" value=\"2.275\" />\n        <xacro:property name=\"link4_mass\" value=\"1.219\" />\n        <xacro:property name=\"link5_mass\" value=\"1.219\" />\n        <xacro:property name=\"link6_mass\" value=\"0.1879\" />  \n\n\t    <xacro:property name=\"base_radius\" value=\"0.060\" /> \n        <xacro:property name=\"link1_radius\" value=\"0.060\" /> \n        <xacro:property name=\"link2_radius\" value=\"0.060\" />   \n        <xacro:property name=\"link3_radius\" value=\"0.060\" />  \n        <xacro:property name=\"link4_radius\" value=\"0.040\" />      \n        <xacro:property name=\"link5_radius\" value=\"0.030\" />   \n        <xacro:property name=\"link6_radius\" value=\"0.025\" /> '''\n        base_link = '''\n\n        \t<!--   Base Link -->\n    <link name=\"${prefix}base_link\" >\n      <visual>\n\t\t<origin xyz=\"0 0 -0.075\" rpy=\"0 0 0\" /> \n        <geometry>\n \t\t\t<cylinder radius=\"${base_radius}\" length=\"${base_length}\"/> \n        </geometry>\n      </visual>\n      <collision>\n\t\t\t<origin xyz=\"0 0 -0.0\" rpy=\"0 0 0\" /> \n        <geometry>\n\t\t\t<cylinder radius=\"${base_radius}\" length=\"${base_length}\"/>\t\n        </geometry>\n      </collision>\n      <xacro:cylinder_inertial radius=\"${base_radius}\" length=\"${base_length}\" mass=\"${base_mass}\">\n        <origin xyz=\"0.0 0.0 -0.075\" rpy=\"0 0 0\" />\n      </xacro:cylinder_inertial>\n    </link>\n    '''\n        data = ''\n\n        for i in range(self.links_number):\n            data = data + self.joint_create(i + 1) + self.link_create(i + 1)\n\n        tail = '''    \n    <joint name=\"${prefix}ee_fixed_joint\" type=\"fixed\">\n      <parent link=\"${prefix}link''' + str(self.links_number) + '''\" />\n      <child link = \"${prefix}ee_link\" />\n      <origin xyz=\"0.0 ${link6_length} 0.0\" rpy=\"0.0 0.0 ${pi/2.0}\" />\n    </joint>\n\n<!-- ee link -->\n    <link name=\"${prefix}ee_link\">\n      <collision>\n        <geometry>\n          <box size=\"0.01 0.01 0.01\"/>\n        </geometry>\n        <origin rpy=\"0 0 0\" xyz=\"-0.01 0 0\"/>\n      </collision>\n    </link>\n\n    <xacro:ur_arm_transmission prefix=\"${prefix}\" />\n    <xacro:ur_arm_gazebo prefix=\"${prefix}\" />\n\n\n\n  </xacro:macro>\n</robot>  '''\n\n        txt = head + inertia_parameters + base_link + data + tail\n        return txt\n\n    def link_create(self, n):\n        '''link- data about specific link. it buit from :\n                *inertia - inertail data of the link -Mass, moment of inertia, pose in the frame\n                *collision - the collision properties of a link.\n                *visual - > the visual properties of the link. This element specifies the shape of the object (box, cylinder, etc.) for visualization purposes\n                *velocity_decay - exponential damping of the link's velocity'''\n        linkname = 'link' + str(n)\n        link = ''\n        if n == 1:\n            link = link + '''<!--  link 1  -->\n    <link name=\"${prefix}link1\">\n      <visual>\n\t\t<origin xyz=\"0 0 ${base_length/2} \" rpy=\"0 0 0\" /> \n        <geometry>\n\t\t\t<cylinder radius=\"${link1_radius}\" length=\"${link1_length}\"/>\t \n        </geometry>\n      </visual>\n      <collision>\n\t\t <origin xyz=\"0 0 ${base_length/2}\" rpy=\"0 0 0\" /> \n        <geometry>\n\t\t\t<cylinder radius=\"${link1_radius}\" length=\"${link1_length}\"/>\n        </geometry>\n      </collision>\n      <xacro:cylinder_inertial radius=\"${link1_radius}\" length=\"${link1_length}\" mass=\"${link1_mass}\">\n        <origin xyz=\"0.0 0.0 ${base_length/2}\" rpy=\"0 0 0\" />\n      </xacro:cylinder_inertial>\n    </link>'''\n        else:\n            link = link + '''<!-- link ''' + str(n) + '''\t-->\n    <link name=\"${prefix}''' + linkname + '''\">\n      <visual>\n\t\t<origin xyz=\"0 0 ${''' + linkname + '''_length / 2}\" rpy=\"0 0 0\" />\n        <geometry>\n\t\t\t<cylinder radius=\"${''' + linkname + '''_radius}\" length=\"${''' + linkname + '''_length}\"/> \n        </geometry>\n      </visual>\n      <collision>\n\t    <origin xyz=\"0 0 ${''' + linkname + '''_length / 2 }\" rpy=\"0 0 0\" />\n        <geometry>\n\t\t<cylinder radius=\"${''' + linkname + '''_radius}\" length=\"${''' + linkname + '''_length}\"/>\n        </geometry>\n      </collision>\n      <xacro:cylinder_inertial radius=\"${''' + linkname + '''_radius}\" length=\"${''' + linkname + '''_length}\" mass=\"${''' + linkname + '''_mass}\">\n        <origin xyz=\"0.0 0.0 ${''' + linkname + '''_length / 2 }\" rpy=\"0 0 0\" />\n      </xacro:cylinder_inertial>\n    </link>'''\n        return link\n\n    def calc_origin(self, n):\n        if n == 2:\n            return '0.0 ${link2_radius + link1_radius} ${link1_length /2 +0.025}'\n        elif n == 3:\n            return '0.0 ${link3_radius+link2_radius} ${link2_length}'\n        elif n == 4:\n            return '0 -${(link4_radius + link3_radius } ${link3_length}'\n        elif n == 5:\n            return '0 0 ${link4_length+link5_radius}'\n        elif n == 6:\n            return '0 0 ${link5_length }'\n\n    # def calc_rpy(self, n):\n    #     if n == 2:\n    #         return '0 0 0'\n    #     elif n == 3:\n    #         return '0 0 0'\n    #     elif n == 4:\n    #         return '0 0 0'\n    #     elif n == 5:\n    #         return '${-pi/2} 0 0'\n    #     elif n == 6:\n    #         return '0 0 0'\n\n    def joint_create(self, n):\n        jointname = 'joint' + str(n)\n        orgin = self.calc_origin(n)\n        rpy = self.rpy[n-1][0]+self.rpy[n-1][1]+self.rpy[n-1][2]\n        joint = '\\n<xacro:property name=\"' + jointname + '_type\" value=\"' + self.joint_data[n - 1] + '\"/>\\n' \\\n                                                                                                     '<xacro:property name=\"' + jointname + '_axe\" value=\"' + \\\n                self.axis[n - 1] + '\"/>\\n' \\\n                                   '<xacro:property name=\"link' + str(n) + '_length\" value=\"' + str(\n            self.links[n - 1]) + '\"/>\\n'\n\n        if n == 1:\n            joint = joint + '''<!--  joint 1\t-->\n    <joint name=\"${prefix}joint1\" type=\"${joint1_type}\">\n      <parent link=\"${prefix}base_link\" />\n      <child link=\"${prefix}link1\" />\n      <origin xyz=\"0.0 0.0 ${(link1_length-0.15)/2}\" rpy=\"0.0 0.0 0.0\" />\n      <axis xyz=\"${joint1_axe}\"/>\n\t  <xacro:joint_limit joint_type=\"${joint1_type}\" link_length=\"${link1_length}\"/>\n      <dynamics damping=\"0.0\" friction=\"0.0\"/>\n    </joint>\n    '''\n        else:\n            joint = joint + '''<!--  joint ''' + str(n) + '''\t-->\n    <joint name=\"${prefix}''' + jointname + '''\" type=\"${''' + jointname + '''_type}\">\n      <parent link=\"${prefix}link''' + str(n - 1) + '''\"/>\n      <child link=\"${prefix}link''' + str(n) + '''\" />\n      <origin xyz=\"''' + orgin + '''\" rpy=\"''' + rpy + '''\"/>\n      <axis xyz=\"${''' + jointname + '''_axe}\"/>\n\t  <xacro:joint_limit joint_type=\"${''' + jointname + '''_type}\" link_length=\"${link''' + str(n) + '''_length}\"/>\n      <dynamics damping=\"0.0\" friction=\"0.0\"/>\n    </joint>\n    '''\n        return joint\n\n    def urdf_write(self, data, filename=str(datetime.datetime.now().minute)):\n        file = open(filename + '.urdf.xacro', 'w')\n        file.write(data)\n        file.close()\n\n    def init_calc(self, joints, joints_axis):\n        axis = []\n        a = 0\n        for j in joints:  # make calculations for all the joints\n            # self.type.append('\\''+j+'\\'')\n            axis.append(self.axis_calc(joints_axis[a]))\n            a = a + 1\n        return axis\n\n    def axis_calc(self, axe):\n        if axe == 'x':  # NO OPTION\n            return '1 0 0'\n        elif axe == 'y':\n            return '0 1 0'\n        elif axe == 'z':\n            return '0 0 1'\n        else:\n            warning('wrong axe input.' + axe + ' entered. returning [0 0 0] ' + str(\n                datetime.datetime.now()))  # will print a message to the console\n            return '0 0 0'\n\n\nclass ToSimulate(object):\n    def __init__(self, number):\n        first_joint=['revolute', 'z', '0', '0.1']\n        link_min = 0.1; link_interval = 0.3; link_max = 1.1\n        lengths_2_check = np.arange(link_min, link_max, link_interval).round(2)\n        #self.links_length =list(itertools.product(lengths_2_check, repeat=(number-1)))\n        #self.joints_axis = list(itertools.product(['y', 'z'], repeat=number-1))\n        #self.joints = list(itertools.product(['prismatic', 'revolute'], repeat=number-1))\n        #self.rpy = list(itertools.product(['0', '-90'], repeat=number-1))\n        self.joints = [[first_joint[0]] + list(tup) for tup in\n                       list(itertools.product(['prismatic', 'revolute'], repeat=number - 1))]\n        self.joints_axis = [[first_joint[1]] + list(tup) for tup in\n                       list(itertools.product(['y', 'z'], repeat=number-1))]\n        self.rpy = [[first_joint[2]] + list(tup) for tup in\n                       list(itertools.product(['0', '-90'], repeat=number-1))]\n        self.links_length = [[first_joint[3]] + list(tup) for tup in\n                       list(itertools.product(lengths_2_check, repeat=(number - 1)))]\n\n    def getaxis(self):\n        return self.joints_axis\n\n    def getjoints(self):\n        return self.joints\n\n    def getlinks(self):\n        return self.links_length\n\n    def getrpy(self):\n        return self.rpy\n\n    def get_combinations(self,links, joints, axis,rpy):\n        '''combine all possible combinations of links and joints'''\n        combinations = len(links) * len(joints) * len(axis)*len(rpy)\n        return combinations\n\n\nclass Assumptinos (object):\n    \"\"\"Assumptions that used to reduce the number of manipulators to simulate\n    explained details in word files and in the functions    \"\"\"\n\n    # @staticmethod\n    # def assume_1(links):\n    #     \"\"\"first link is always 0.1 meter\"\"\"\n    #     if links[0]== 1.0:\n    #         return True\n    #     return False\n    #\n    # @staticmethod\n    # def assume_2(axe):\n    #     \"\"\"first joint axe is always z axe \"\"\"\n    #     if axe == 'z':\n    #        return True\n    #     return False\n\n    # @staticmethod\n    # def assume_4(joint_types):\n    #     \"\"\"first joint is always revolute\"\"\"\n    #     if joint_types[0] == 'prismatic':\n    #         return False\n    #     return True\n    #\n    # @staticmethod\n    # def assume_5(roll):\n    #     \"\"\"first joint roll is always 0 \"\"\"\n    #     if roll[0] == '-90':\n    #         return False\n    #     return True\n\n    # @staticmethod\n    # def assume_7(joints, rpy):\n    #     \"\"\" two adjacent prismatics joints won't be parallel \"\"\"\n    #     prev_joint = 'revolute'\n    #     for j in range(2, len(joints) + 1):\n    #         if joints[j - 1] == 'prismatic' and prev_joint == 'prismatic' and rpy[j - 1] != '-90':  # or axis[j] == 'y':\n    #             return False\n    #         prev_joint = joints[j - 1]\n    #     return True\n\n    @staticmethod\n    def assume_3(joint_types):\n        \"\"\"No more than 3 parismatics joints\"\"\"\n        tot = 0\n        for j in joint_types:\n            if j == 'prismatic':\n                tot = tot+1\n            if tot > 3:\n                return False\n        return True\n\n    @staticmethod\n    def assume_6(joint_types, axis, rpy):\n        \"\"\"If the second joint is revolute than it must be perpendicular to the first \"\"\"\n        prev_joint = 'revolute'\n        prev_axe = 'z'\n        for j in range(2, len(joint_types)+1):\n            if prev_joint == 'revolute' and joint_types[j-1] == 'revolute' and axis[j-1] == prev_axe and rpy[j-1] == '0':\n                return False\n            prev_joint == joint_types[j-1]\n            prev_axe = axis[j-1]\n        return True\n\n    @staticmethod\n    def assume_8(joints, axis):\n        \"\"\"Prismatic is always through Z axe\"\"\"\n        for j in range(2, len(joints)+1):\n            if axis[j-1] == 'y' and joints[j-1] == 'prismatic':\n                return False\n        return True\n\n    @staticmethod\n    def setrpy(rpy, joints):\n        \"\"\"Set roll or pitch to joint  \"\"\"\n        rpy_new = [['0 ', '0 ', '0 ']]\n        pris_num = 0   # how many parismatics in raw\n        rpy_name = '0 ,'  # name of file\n        for j in range(2, len(joints)+1):\n            if joints[j-1] == 'revolute':\n                if rpy[j-1] == '0':\n                    rpy_new.append(['0 ', '0 ', '0 '])\n                    rpy_name += '0 ,'\n                else:\n                    rpy_new.append(['${-pi/2} ', '0 ', '0 '])\n                    rpy_name += '-90 ,'\n                pris_num = 0\n            else:\n                if pris_num == 1:\n                    rpy_new.append(['${-pi/2} ', '0 ', '0 '])\n                    rpy_name += '-90 ,'\n                elif pris_num == 0:\n                    if rpy[j - 1] == '0':\n                        rpy_new.append(['0 ', '0 ', '0 '])\n                        rpy_name += '0 ,'\n                    else:\n                        rpy_new.append(['${-pi/2} ', '0 ', '0 '])\n                        rpy_name += '-90 ,'\n                    pris_num = 0\n                else:\n                    rpy_new.append(['0 ', '${-pi/2} ', '0 '])\n                    rpy_name += '-90y ,'\n                pris_num = pris_num + 1\n        return rpy_new,rpy_name\n\n    @staticmethod\n    def assume_3_4_count(number, counter):\n        return counter+(16**number)/16\n\n    @staticmethod\n    def assume_2_6_count(number, counter):\n        return counter + (8**number)/8\n\n\ndef create_folder(name):\n    if not os.path.exists(name):\n        os.mkdir(name)\n    return name\n\n\ndef run():\n    tic = datetime.datetime.now()\n    combinations = 0\n    base_folder = '/home/tamir/' + 'urdf_' + str(datetime.datetime.now().date())  # '/media/arl_main/New Volume/'+\n    base_folder = create_folder(base_folder)\n    assum = Assumptinos()\n    d = 0\n    t = 0\n    u = 0\n    p = 0\n    x = 0\n    for n in range(3, 7):\n        sim = ToSimulate(n)\n        links_sim = sim.getlinks()  # create all possible links combinations\n        joints_sim = sim.getjoints()  # create all possible joints combinations\n        axis_sim = sim.getaxis()  # create all possible axis combinations\n        rpy_sim = sim.getrpy()  # create all possible rpy combinations\n        path = base_folder + '/DOF_' + str(n) + '/'  # where to save the files\n        create_folder(path)\n        for i in range(len(joints_sim)):  # run about all the joints combination\n            if not assum.assume_3(joints_sim[i]):  # check if the joint meets assumption 3\n                d = assum.assume_3_4_count(n, d)\n                continue\n            joints_path = create_folder(path + str(joints_sim[i]))  # create folder with the joints types\n            for a in range(len(axis_sim)):  # run about all the axis combination\n                if not assum.assume_8(joints_sim[i], axis_sim[a]):  # check if the joint meets assumption 6\n                    x = assum.assume_2_6_count(n, x)\n                    continue\n                axis_path = create_folder(joints_path + '/' + str(axis_sim[a]))\n                for j in range(len(links_sim)):  # run about all the links combination\n                    link_path = create_folder(axis_path + '/' + str(links_sim[j]))\n                    for k in range(len(rpy_sim)):  # run about all the rpy combination\n                        if not assum.assume_6(joints_sim[i], axis_sim[a],rpy_sim[k]):  # check if the joint meets assumption 6\n                            u = u+1\n                            continue\n                        rpy,rpy_name = assum.setrpy(rpy_sim[k], joints_sim[i])\n                        urdf_name = link_path + '/' + str(rpy_name)\n                        urdf = UrdfClass(links_sim[j], joints_sim[i], axis_sim[a], rpy)\n                        urdf.urdf_write(urdf.urdf_data(), urdf_name)\n                        t = t + 1\n        combinations = sim.get_combinations(links_sim, joints_sim, axis_sim, rpy_sim) + combinations\n    toc = datetime.datetime.now()\n    delta = (toc - tic).seconds\n\n    print('Pre filtered combinations: ' + str(combinations))\n    print('Amount of manipulators that filtered total: ' + str(d+u+p+x))\n    print('Amount of manipulators after filteting: ' + str(t))\n    print('Amount of manipulators that filtered due assum 8: ' + str(x))\n    print('Amount of manipulators that filtered due assum 6: '+str(u))\n    print('Amount of manipulators that filtered due assum 3: '+str(d))\n    print('Time of Run (seconds): ' + str(delta))\n    print('Combinations per second: ' + str(1.0*combinations/delta))\n\n\nif __name__ == \"__main__\":\n    # tic = datetime.datetime.now()\n    # combinations = 0\n    # base_folder = '/home/arl_main/'+'urdf_'+str(datetime.datetime.now().date())  # '/media/arl_main/New Volume/'+\n    # base_folder = create_folder(base_folder)\n    # assum = Assumptinos()\n    # d = 0; o = 0; t = 0; z = 0; q = 0; r = 0; u = 0; p = 0; x = 0\n    # for n in range(3, 5):\n    #     sim = ToSimulate(n)\n    #     links_sim = sim.getlinks()    # create all possible links combinations\n    #     joints_sim = sim.getjoints()  # create all possible joints combinations\n    #     axis_sim = sim.getaxis()      # create all possible axis combinations\n    #     rpy_sim = sim.getrpy()        # create all possible rpy combinations\n    #     path = base_folder+'/DOF_' + str(n) + '/'  # where to save the files\n    #     create_folder(path)\n    #     for i in range(len(joints_sim)):  # run about all the joints combination\n    #         # if not assum.assume_4(joints_sim[i]):  # check if the joint meets assumption 4\n    #         #     q = assum.assume_3_4_count(n, q)\n    #         #     continue\n    #         if not assum.assume_3(joints_sim[i]):  # check if the joint meets assumption 3\n    #             d = assum.assume_3_4_count(n, d)\n    #             continue\n    #         joints_path = create_folder(path + str(joints_sim[i]))  # create folder with the joints types\n    #         for a in range(len(axis_sim)):  # run about all the axis combination\n    #             # if not assum.assume_2(axis_sim[a][0]):  # check if the joint meets  assumption 2\n    #             #     o = assum.assume_2_6_count(n, o)\n    #             #     continue\n    #             if not assum.assume_6(joints_sim[i], axis_sim[a]):  # check if the joint meets assumption 6\n    #                 u = assum.assume_2_6_count(n, u)\n    #                 continue\n    #             if not assum.assume_8(joints_sim[i], axis_sim[a]):  # check if the joint meets assumption 6\n    #                 x = assum.assume_2_6_count(n, x)\n    #                 continue\n    #             axis_path = create_folder(joints_path + '/' + str(axis_sim[a]))\n    #             for j in range(len(links_sim)):  # run about all the links combination\n    #                 # if not assum.assume_1(links_sim[j]):  # check if the joint meets assumption 1\n    #                 #     z = assum.assume_1_count(n, z)\n    #                 #     continue\n    #                 link_path = create_folder(axis_path + '/' + str(links_sim[j]))\n    #                 for k in range(len(rpy_sim)):  # run about all the rpy combination\n    #                     # if not assum.assume_5(rpy_sim[k]):  # check if the joint meets assumption 5\n    #                     #     r = r+1\n    #                     #     continue\n    #                     if not assum.assume_7(joints_sim[i], rpy_sim[k]):  # check if the joint meets the assumption 7\n    #                         p = p + 1\n    #                         continue\n    #                     urdf_name = link_path + '/' + str(rpy_sim[k])\n    #                     urdf = UrdfClass(links_sim[j], joints_sim[i], axis_sim[a], ''.join( rpy_sim[k]))\n    #                     urdf.urdf_write(urdf.urdf_data(), urdf_name)\n    #                     t = t+1\n    #     combinations = sim.get_combinations(links_sim, joints_sim, axis_sim, rpy_sim)+combinations\n    # toc = datetime.datetime.now()\n    # delta = (toc-tic).seconds\n    # print('Pre filtered combinations: ' + str(combinations))\n    # print('Amount of manipulators that filtered total: ' + str(d+u+p+x))\n    # print('Amount of manipulators after filteting: ' + str(t))\n    # print('Amount of manipulators that filtered due assum 8: ' + str(x))\n    # print('Amount of manipulators that filtered due assum 7: '+str(p))\n    # print('Amount of manipulators that filtered due assum 6: '+str(u))\n    # #print('Amount of manipulators that filtered due assum 5: '+str(r))\n    # #print('Amount of manipulators that filtered due assum 4: '+str(q))\n    # print('Amount of manipulators that filtered due assum 3: '+str(d))\n    # #print('Amount of manipulators that filtered due assum 2: '+str(o))\n    # #print('Amount of manipulators that filtered due assum 1: '+str(z))\n    # print('Time of Run (seconds): ' + str(delta))\n    # print('Combinations per second: ' + str(1.0*combinations/delta))\n    run()\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- SimFilesCreate.py	(revision 9471f81a6a8d7a0d6d81bd659d8eece643f9cc85)
+++ SimFilesCreate.py	(date 1556694446035)
@@ -428,7 +428,7 @@
 def run():
     tic = datetime.datetime.now()
     combinations = 0
-    base_folder = '/home/tamir/' + 'urdf_' + str(datetime.datetime.now().date())  # '/media/arl_main/New Volume/'+
+    base_folder = '/home/arl_main/' + 'urdf_' + str(datetime.datetime.now().date())  # '/media/arl_main/New Volume/'+
     base_folder = create_folder(base_folder)
     assum = Assumptinos()
     d = 0
@@ -436,7 +436,7 @@
     u = 0
     p = 0
     x = 0
-    for n in range(3, 7):
+    for n in range(3, 4):
         sim = ToSimulate(n)
         links_sim = sim.getlinks()  # create all possible links combinations
         joints_sim = sim.getjoints()  # create all possible joints combinations
@@ -546,3 +546,4 @@
     # print('Time of Run (seconds): ' + str(delta))
     # print('Combinations per second: ' + str(1.0*combinations/delta))
     run()
+
